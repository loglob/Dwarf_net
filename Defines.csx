#!/usr/bin/env dotnet-script
// Defines.csx: Generates an enum containing the preprocessor definitions from dwarf.h and libdwarf.h
using System.Globalization;
using System.Text.RegularExpressions;

/** Type modifiers prepended to enum type definitions */
const string enumModifiers = "";

static readonly (string, string)[] manual = {
	("DW_DLV_BADADDR", "(IntPtr)-1L"),
	("DW_DLV_NOCOUNT", "-1L"),
	("DW_DLV_BADOFFSET", "(IntPtr)-1L")
};

static string RemoveComment(string s)
{
	var ss = s.Split("/*", 2);

	if(ss.Length == 2)
		return ss[0] + RemoveComment(ss[1].Split("*/",2)[1]);
	else
		return s.Split("//", 2)[0];
}

/** extracts enums from the file.
	Does NOT scan for typedefs */
static IEnumerable<string> extractEnums(string file)
	=> new Regex(@"enum\s+\S+\s*{.*?}", RegexOptions.Singleline)
		.Matches(file)
		.Select(m => m.Value);

delegate bool MaybeFunc<A, B>(A input, out B output);

static IEnumerable<B> SelectWhere<A,B>(this IEnumerable<A> ls, MaybeFunc<A,B> f)
{
	foreach (var a in ls)
	{
		if(f(a, out var b))
			yield return b;
	}
}

/** extracts preprocessor definitions from the file.
	Does NOT run a full preprocessor (i.e. doesn't check for #ifdef) */
static IEnumerable<(string name, string val)> extractDefines(string file)
	=> new Regex(@"^#define\s+(\S+)[ 	]+(.*?)$", RegexOptions.Multiline)
		.Matches(file)
		.Select(m => (m.Groups[1].Value, m.Groups[2].Value.Trim()))
		.Distinct()
		.SelectWhere(((string name, string val) d, out (string name, string val) v) => {
			v = (d.name, translateNumberFromC(d.val));

			if(v.val is null)
			{
				Console.Error.WriteLine($"Omitting '#define {d.name} {d.val}'");
				return false;
			}

			return true;
		});

private static B foldr<A,B>(this IEnumerable<A> ls, Func<B,A,B> f, B zero)
{
	B cur = zero;

	foreach (var a in ls)
		cur = f(cur, a);

	return cur;
}

// null-safe concat
private static string cc(this string l, string r)
	=> (l is null || r is null) ? null : l + r;

/** Parses a C integer literal and translates it to a C# integer literal.
	Does NOT support manual type casting or bitwise operations */
private static string translateNumberFromC(string val)
{
	if(val.StartsWith("(") && val.EndsWith(")"))
		return translateNumberFromC(val.Substring(1, val.Length - 2));

	// accept references
	if(new Regex(@"^\w+$").IsMatch(val))
		return val;
	if(val.Contains('+'))
	{
		var s = val.Split('+', 2, StringSplitOptions.TrimEntries);
		return translateNumberFromC(s[0]).cc(" + ").cc(translateNumberFromC(s[1]));
	}
	if(val.EndsWith("LL"))
		return translateNumberFromC(val.Substring(0, val.Length - 2)).cc("L");
	if(val.EndsWith("L"))
		return translateNumberFromC(val.Substring(0, val.Length - 1)).cc("L");
	if(val.StartsWith("-"))
		return "-".cc(translateNumberFromC(val.Substring(1)));

	if(val.StartsWith("0x") || (val[0] >= '1' && val[0] <= '9'))
		return val;
	if(val.StartsWith("0") &&  val.All(c => c >= '0' && c <= '7'))
		return (val.foldr((x,c) => (x << 3) | (ulong)(uint)(c - '0'), 0UL) >> 3).ToString();

	return null;
}

public static string JoinLines(this IEnumerable<string> s)
	=> string.Join('\n', s);

string literalType(string val)
	=> new Regex(@"\dL$").IsMatch(val) ? "long" : "int";

/** Generates an enum definition from the preprocessor definitions on the file */
string defineEnum(string file, string name = "Defines")
	=> $"	{enumModifiers}static class {name}\n" +
		"	{\n" +
		extractDefines(file)
			.Select(d =>
		$"		public const {literalType(d.val)} {d.name} = {d.val};")
			.JoinLines() +
		"\n	}";

string input = string.Join('\n', Directory.GetFiles("/usr/include/libdwarf/")
	.Select(File.ReadAllText)
	.Select(RemoveComment));

const string outfile = "Defines.cs";

void fill(TextWriter o)
{
	o.WriteLine(
		$"// {outfile}: Generated by Defines.csx, contains libdwarf's enums\n" + 
		"using System;\n" +
		"\n" +
		"namespace Dwarf_net\n" +
		"{");

	o.WriteLine(defineEnum(input));

	foreach(var e in extractEnums(input))
		o.WriteLine("\t" + e.Replace("\n", "\n\t"));

	o.WriteLine("}");
}

using(var f = File.CreateText(outfile))
	fill(f);